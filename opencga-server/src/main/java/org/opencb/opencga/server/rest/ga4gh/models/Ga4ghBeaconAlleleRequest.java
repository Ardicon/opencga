/*
 * GA4GH Beacon API Specification
 * A Beacon is a web service for genetic data sharing that can be queried for  information about variants, individuals or samples.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: beacon@ga4gh.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.opencb.opencga.server.rest.ga4gh.models;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import javax.validation.Valid;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Allele request made against the beacon. The allele must be mapped  against a sequence in a genome, and a range can be optionally specified. 
 */
@ApiModel(description = "Allele request made against the beacon. The allele must be mapped  against a sequence in a genome, and a range can be optionally specified. ")
@JsonPropertyOrder({
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_REFERENCE_NAME,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_START,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_END,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_START_MIN,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_START_MAX,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_END_MIN,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_END_MAX,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_REFERENCE_BASES,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_ALTERNATE_BASES,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_VARIANT_TYPE,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_MATE_NAME,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_ASSEMBLY_ID,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_DATASET_IDS,
  Ga4ghBeaconAlleleRequest.JSON_PROPERTY_INCLUDE_DATASET_RESPONSES
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaJerseyServerCodegen", date = "2020-03-24T15:12:46.170Z[Europe/London]")
public class Ga4ghBeaconAlleleRequest   {
  public static final String JSON_PROPERTY_REFERENCE_NAME = "referenceName";
  @JsonProperty(JSON_PROPERTY_REFERENCE_NAME)
  private Ga4ghChromosome referenceName;

  public static final String JSON_PROPERTY_START = "start";
  @JsonProperty(JSON_PROPERTY_START)
  private Long start;

  public static final String JSON_PROPERTY_END = "end";
  @JsonProperty(JSON_PROPERTY_END)
  private Integer end;

  public static final String JSON_PROPERTY_START_MIN = "startMin";
  @JsonProperty(JSON_PROPERTY_START_MIN)
  private Integer startMin;

  public static final String JSON_PROPERTY_START_MAX = "startMax";
  @JsonProperty(JSON_PROPERTY_START_MAX)
  private Integer startMax;

  public static final String JSON_PROPERTY_END_MIN = "endMin";
  @JsonProperty(JSON_PROPERTY_END_MIN)
  private Integer endMin;

  public static final String JSON_PROPERTY_END_MAX = "endMax";
  @JsonProperty(JSON_PROPERTY_END_MAX)
  private Integer endMax;

  public static final String JSON_PROPERTY_REFERENCE_BASES = "referenceBases";
  @JsonProperty(JSON_PROPERTY_REFERENCE_BASES)
  private String referenceBases;

  public static final String JSON_PROPERTY_ALTERNATE_BASES = "alternateBases";
  @JsonProperty(JSON_PROPERTY_ALTERNATE_BASES)
  private String alternateBases;

  public static final String JSON_PROPERTY_VARIANT_TYPE = "variantType";
  @JsonProperty(JSON_PROPERTY_VARIANT_TYPE)
  private String variantType;

  public static final String JSON_PROPERTY_MATE_NAME = "mateName";
  @JsonProperty(JSON_PROPERTY_MATE_NAME)
  private Ga4ghChromosome mateName;

  public static final String JSON_PROPERTY_ASSEMBLY_ID = "assemblyId";
  @JsonProperty(JSON_PROPERTY_ASSEMBLY_ID)
  private String assemblyId;

  public static final String JSON_PROPERTY_DATASET_IDS = "datasetIds";
  @JsonProperty(JSON_PROPERTY_DATASET_IDS)
  private List<String> datasetIds = null;

  /**
   * Indicator of whether responses for individual datasets (datasetAlleleResponses) should be included in the response (BeaconAlleleResponse) to this request or not. If null (not specified), the default value of NONE is assumed.
   */
  public enum IncludeDatasetResponsesEnum {
    ALL("ALL"),
    
    HIT("HIT"),
    
    MISS("MISS"),
    
    NONE("NONE");

    private String value;

    IncludeDatasetResponsesEnum(String value) {
      this.value = value;
    }

    @Override
    @JsonValue
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static IncludeDatasetResponsesEnum fromValue(String value) {
      for (IncludeDatasetResponsesEnum b : IncludeDatasetResponsesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_INCLUDE_DATASET_RESPONSES = "includeDatasetResponses";
  @JsonProperty(JSON_PROPERTY_INCLUDE_DATASET_RESPONSES)
  private IncludeDatasetResponsesEnum includeDatasetResponses;

  public Ga4ghBeaconAlleleRequest referenceName(Ga4ghChromosome referenceName) {
    this.referenceName = referenceName;
    return this;
  }

  /**
   * Get referenceName
   * @return referenceName
   **/
  @JsonProperty("referenceName")
  @ApiModelProperty(required = true, value = "")
  @NotNull @Valid 
  public Ga4ghChromosome getReferenceName() {
    return referenceName;
  }

  public void setReferenceName(Ga4ghChromosome referenceName) {
    this.referenceName = referenceName;
  }

  public Ga4ghBeaconAlleleRequest start(Long start) {
    this.start = start;
    return this;
  }

  /**
   * Precise start coordinate position, allele locus (0-based, inclusive). * start only:   - for single positions, e.g. the start of a specified sequence    alteration where the size is given through the specified    &#x60;alternateBases&#x60;   - typical use are queries for SNV and small InDels   - the use of \&quot;start\&quot; without an \&quot;end\&quot; parameter requires the use    of \&quot;referenceBases\&quot; * start and end:   - special use case for exactly determined structural changes 
   * minimum: 0
   * @return start
   **/
  @JsonProperty("start")
  @ApiModelProperty(value = "Precise start coordinate position, allele locus (0-based, inclusive). * start only:   - for single positions, e.g. the start of a specified sequence    alteration where the size is given through the specified    `alternateBases`   - typical use are queries for SNV and small InDels   - the use of \"start\" without an \"end\" parameter requires the use    of \"referenceBases\" * start and end:   - special use case for exactly determined structural changes ")
   @Min(0L)
  public Long getStart() {
    return start;
  }

  public void setStart(Long start) {
    this.start = start;
  }

  public Ga4ghBeaconAlleleRequest end(Integer end) {
    this.end = end;
    return this;
  }

  /**
   * Precise end coordinate (0-based, exclusive). See start.
   * @return end
   **/
  @JsonProperty("end")
  @ApiModelProperty(value = "Precise end coordinate (0-based, exclusive). See start.")
  
  public Integer getEnd() {
    return end;
  }

  public void setEnd(Integer end) {
    this.end = end;
  }

  public Ga4ghBeaconAlleleRequest startMin(Integer startMin) {
    this.startMin = startMin;
    return this;
  }

  /**
   * Minimum start coordinate * startMin + startMax + endMin + endMax   - for querying imprecise positions (e.g. identifying all    structural variants starting anywhere between &#x60;startMin&#x60; &lt;-&gt;    &#x60;startMax&#x60;, and ending anywhere between endMin &lt;-&gt; endMax)   - single or double sided precise matches can be achieved by    setting &#x60;startMin&#x60; &#x3D; &#x60;startMax&#x60; XOR &#x60;endMin&#x60; &#x3D; &#x60;endMax&#x60; 
   * @return startMin
   **/
  @JsonProperty("startMin")
  @ApiModelProperty(value = "Minimum start coordinate * startMin + startMax + endMin + endMax   - for querying imprecise positions (e.g. identifying all    structural variants starting anywhere between `startMin` <->    `startMax`, and ending anywhere between endMin <-> endMax)   - single or double sided precise matches can be achieved by    setting `startMin` = `startMax` XOR `endMin` = `endMax` ")
  
  public Integer getStartMin() {
    return startMin;
  }

  public void setStartMin(Integer startMin) {
    this.startMin = startMin;
  }

  public Ga4ghBeaconAlleleRequest startMax(Integer startMax) {
    this.startMax = startMax;
    return this;
  }

  /**
   * Maximum start coordinate. See &#x60;startMin&#x60;. 
   * @return startMax
   **/
  @JsonProperty("startMax")
  @ApiModelProperty(value = "Maximum start coordinate. See `startMin`. ")
  
  public Integer getStartMax() {
    return startMax;
  }

  public void setStartMax(Integer startMax) {
    this.startMax = startMax;
  }

  public Ga4ghBeaconAlleleRequest endMin(Integer endMin) {
    this.endMin = endMin;
    return this;
  }

  /**
   * Minimum end coordinate. See &#x60;startMin&#x60;. 
   * @return endMin
   **/
  @JsonProperty("endMin")
  @ApiModelProperty(value = "Minimum end coordinate. See `startMin`. ")
  
  public Integer getEndMin() {
    return endMin;
  }

  public void setEndMin(Integer endMin) {
    this.endMin = endMin;
  }

  public Ga4ghBeaconAlleleRequest endMax(Integer endMax) {
    this.endMax = endMax;
    return this;
  }

  /**
   * Maximum end coordinate. See &#x60;startMin&#x60;. 
   * @return endMax
   **/
  @JsonProperty("endMax")
  @ApiModelProperty(value = "Maximum end coordinate. See `startMin`. ")
  
  public Integer getEndMax() {
    return endMax;
  }

  public void setEndMax(Integer endMax) {
    this.endMax = endMax;
  }

  public Ga4ghBeaconAlleleRequest referenceBases(String referenceBases) {
    this.referenceBases = referenceBases;
    return this;
  }

  /**
   * Reference bases for this variant (starting from &#x60;start&#x60;). Accepted  values: [ACGTN]*. N is a wildcard, that denotes the position of any  base, and can be used as a standalone base of any type or within a  partially known sequence. For example a sequence where the first and  last bases are known, but the middle portion can exhibit countless  variations of [ACGT], or the bases are unknown: ANNT the Ns can take  any form of [ACGT], which makes both ACCT and ATGT (or any  other combination) viable sequences. 
   * @return referenceBases
   **/
  @JsonProperty("referenceBases")
  @ApiModelProperty(required = true, value = "Reference bases for this variant (starting from `start`). Accepted  values: [ACGTN]*. N is a wildcard, that denotes the position of any  base, and can be used as a standalone base of any type or within a  partially known sequence. For example a sequence where the first and  last bases are known, but the middle portion can exhibit countless  variations of [ACGT], or the bases are unknown: ANNT the Ns can take  any form of [ACGT], which makes both ACCT and ATGT (or any  other combination) viable sequences. ")
  @NotNull  @Pattern(regexp="^([ACGTN]+)$")
  public String getReferenceBases() {
    return referenceBases;
  }

  public void setReferenceBases(String referenceBases) {
    this.referenceBases = referenceBases;
  }

  public Ga4ghBeaconAlleleRequest alternateBases(String alternateBases) {
    this.alternateBases = alternateBases;
    return this;
  }

  /**
   * The bases that appear instead of the reference bases. Accepted  values: [ACGTN]*. N is a wildcard, that denotes the position of any  base, and can be used as a standalone base of any type or within a  partially known sequence. For example a sequence where the first and  last bases are known, but the middle portion can exhibit countless  variations of [ACGT], or the bases are unknown: ANNT the Ns can take  any form of [ACGT], which makes both ACCT and ATGT (or any other  combination) viable sequences.  Symbolic ALT alleles (DEL, INS, DUP, INV, CNV, DUP:TANDEM, DEL:ME, INS:ME) will be represented in &#x60;variantType&#x60;.  Optional: either &#x60;alternateBases&#x60; or &#x60;variantType&#x60; is required. 
   * @return alternateBases
   **/
  @JsonProperty("alternateBases")
  @ApiModelProperty(value = "The bases that appear instead of the reference bases. Accepted  values: [ACGTN]*. N is a wildcard, that denotes the position of any  base, and can be used as a standalone base of any type or within a  partially known sequence. For example a sequence where the first and  last bases are known, but the middle portion can exhibit countless  variations of [ACGT], or the bases are unknown: ANNT the Ns can take  any form of [ACGT], which makes both ACCT and ATGT (or any other  combination) viable sequences.  Symbolic ALT alleles (DEL, INS, DUP, INV, CNV, DUP:TANDEM, DEL:ME, INS:ME) will be represented in `variantType`.  Optional: either `alternateBases` or `variantType` is required. ")
   @Pattern(regexp="^([ACGTN]+)$")
  public String getAlternateBases() {
    return alternateBases;
  }

  public void setAlternateBases(String alternateBases) {
    this.alternateBases = alternateBases;
  }

  public Ga4ghBeaconAlleleRequest variantType(String variantType) {
    this.variantType = variantType;
    return this;
  }

  /**
   * The &#x60;variantType&#x60; is used to denote e.g. structural variants.  Examples: * DUP: duplication of sequence following &#x60;start&#x60;; not necessarily in situ * DEL: deletion of sequence following &#x60;start&#x60; * BND: breakend, i.e. termination of the allele at position       &#x60;start&#x60; or in the &#x60;startMin&#x60; &#x3D;&gt; &#x60;startMax&#x60; interval, or fusion       of the sequence to distant partner   Optional: either &#x60;alternateBases&#x60; or &#x60;variantType&#x60; is required. 
   * @return variantType
   **/
  @JsonProperty("variantType")
  @ApiModelProperty(value = "The `variantType` is used to denote e.g. structural variants.  Examples: * DUP: duplication of sequence following `start`; not necessarily in situ * DEL: deletion of sequence following `start` * BND: breakend, i.e. termination of the allele at position       `start` or in the `startMin` => `startMax` interval, or fusion       of the sequence to distant partner   Optional: either `alternateBases` or `variantType` is required. ")
  
  public String getVariantType() {
    return variantType;
  }

  public void setVariantType(String variantType) {
    this.variantType = variantType;
  }

  public Ga4ghBeaconAlleleRequest mateName(Ga4ghChromosome mateName) {
    this.mateName = mateName;
    return this;
  }

  /**
   * Get mateName
   * @return mateName
   **/
  @JsonProperty("mateName")
  @ApiModelProperty(value = "")
  @Valid 
  public Ga4ghChromosome getMateName() {
    return mateName;
  }

  public void setMateName(Ga4ghChromosome mateName) {
    this.mateName = mateName;
  }

  public Ga4ghBeaconAlleleRequest assemblyId(String assemblyId) {
    this.assemblyId = assemblyId;
    return this;
  }

  /**
   * Assembly identifier (GRC notation, e.g. &#x60;GRCh37&#x60;). 
   * @return assemblyId
   **/
  @JsonProperty("assemblyId")
  @ApiModelProperty(example = "GRCh38", required = true, value = "Assembly identifier (GRC notation, e.g. `GRCh37`). ")
  @NotNull 
  public String getAssemblyId() {
    return assemblyId;
  }

  public void setAssemblyId(String assemblyId) {
    this.assemblyId = assemblyId;
  }

  public Ga4ghBeaconAlleleRequest datasetIds(List<String> datasetIds) {
    this.datasetIds = datasetIds;
    return this;
  }

  public Ga4ghBeaconAlleleRequest addDatasetIdsItem(String datasetIdsItem) {
    if (this.datasetIds == null) {
      this.datasetIds = new ArrayList<String>();
    }
    this.datasetIds.add(datasetIdsItem);
    return this;
  }

  /**
   * Identifiers of datasets, as defined in &#x60;BeaconDataset&#x60;. If this field is null/not specified, all datasets should be queried.
   * @return datasetIds
   **/
  @JsonProperty("datasetIds")
  @ApiModelProperty(value = "Identifiers of datasets, as defined in `BeaconDataset`. If this field is null/not specified, all datasets should be queried.")
  
  public List<String> getDatasetIds() {
    return datasetIds;
  }

  public void setDatasetIds(List<String> datasetIds) {
    this.datasetIds = datasetIds;
  }

  public Ga4ghBeaconAlleleRequest includeDatasetResponses(IncludeDatasetResponsesEnum includeDatasetResponses) {
    this.includeDatasetResponses = includeDatasetResponses;
    return this;
  }

  /**
   * Indicator of whether responses for individual datasets (datasetAlleleResponses) should be included in the response (BeaconAlleleResponse) to this request or not. If null (not specified), the default value of NONE is assumed.
   * @return includeDatasetResponses
   **/
  @JsonProperty("includeDatasetResponses")
  @ApiModelProperty(value = "Indicator of whether responses for individual datasets (datasetAlleleResponses) should be included in the response (BeaconAlleleResponse) to this request or not. If null (not specified), the default value of NONE is assumed.")
  
  public IncludeDatasetResponsesEnum getIncludeDatasetResponses() {
    return includeDatasetResponses;
  }

  public void setIncludeDatasetResponses(IncludeDatasetResponsesEnum includeDatasetResponses) {
    this.includeDatasetResponses = includeDatasetResponses;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Ga4ghBeaconAlleleRequest beaconAlleleRequest = (Ga4ghBeaconAlleleRequest) o;
    return Objects.equals(this.referenceName, beaconAlleleRequest.referenceName) &&
        Objects.equals(this.start, beaconAlleleRequest.start) &&
        Objects.equals(this.end, beaconAlleleRequest.end) &&
        Objects.equals(this.startMin, beaconAlleleRequest.startMin) &&
        Objects.equals(this.startMax, beaconAlleleRequest.startMax) &&
        Objects.equals(this.endMin, beaconAlleleRequest.endMin) &&
        Objects.equals(this.endMax, beaconAlleleRequest.endMax) &&
        Objects.equals(this.referenceBases, beaconAlleleRequest.referenceBases) &&
        Objects.equals(this.alternateBases, beaconAlleleRequest.alternateBases) &&
        Objects.equals(this.variantType, beaconAlleleRequest.variantType) &&
        Objects.equals(this.mateName, beaconAlleleRequest.mateName) &&
        Objects.equals(this.assemblyId, beaconAlleleRequest.assemblyId) &&
        Objects.equals(this.datasetIds, beaconAlleleRequest.datasetIds) &&
        Objects.equals(this.includeDatasetResponses, beaconAlleleRequest.includeDatasetResponses);
  }

  @Override
  public int hashCode() {
    return Objects.hash(referenceName, start, end, startMin, startMax, endMin, endMax, referenceBases, alternateBases, variantType, mateName, assemblyId, datasetIds, includeDatasetResponses);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Ga4ghBeaconAlleleRequest {\n");

    sb.append("    referenceName: ").append(toIndentedString(referenceName)).append("\n");
    sb.append("    start: ").append(toIndentedString(start)).append("\n");
    sb.append("    end: ").append(toIndentedString(end)).append("\n");
    sb.append("    startMin: ").append(toIndentedString(startMin)).append("\n");
    sb.append("    startMax: ").append(toIndentedString(startMax)).append("\n");
    sb.append("    endMin: ").append(toIndentedString(endMin)).append("\n");
    sb.append("    endMax: ").append(toIndentedString(endMax)).append("\n");
    sb.append("    referenceBases: ").append(toIndentedString(referenceBases)).append("\n");
    sb.append("    alternateBases: ").append(toIndentedString(alternateBases)).append("\n");
    sb.append("    variantType: ").append(toIndentedString(variantType)).append("\n");
    sb.append("    mateName: ").append(toIndentedString(mateName)).append("\n");
    sb.append("    assemblyId: ").append(toIndentedString(assemblyId)).append("\n");
    sb.append("    datasetIds: ").append(toIndentedString(datasetIds)).append("\n");
    sb.append("    includeDatasetResponses: ").append(toIndentedString(includeDatasetResponses)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

